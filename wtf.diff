diff --git a/kernel/defs.h b/kernel/defs.h
index 0b5d5bc..c767eb8 100644
--- a/kernel/defs.h
+++ b/kernel/defs.h
@@ -46,6 +46,7 @@ int             filewrite(struct file*, uint64, int n);
 
 // fs.c
 void            fsinit(int);
+uint            bmap(struct inode*, uint);
 int             dirlink(struct inode*, char*, uint);
 struct inode*   dirlookup(struct inode*, char*, uint*);
 struct inode*   ialloc(uint, short);
@@ -173,7 +174,7 @@ int             mappages(pagetable_t, uint64, uint64, uint64, int);
 pagetable_t     uvmcreate(void);
 void            uvmfirst(pagetable_t, uchar *, uint);
 uint64          uvmalloc(pagetable_t, uint64, uint64, int);
-uint64          uvmmap(pagetable_t, uint64, uint64, int, int);
+uint64          uvmmap(pagetable_t, uint64, uint64, int, int, int);
 uint64          uvmdealloc(pagetable_t, uint64, uint64);
 int             uvmcopy(pagetable_t, pagetable_t, uint64);
 void            uvmfree(pagetable_t, uint64);
diff --git a/kernel/exec.c b/kernel/exec.c
index 7cdfa91..de3d756 100644
--- a/kernel/exec.c
+++ b/kernel/exec.c
@@ -70,6 +70,10 @@ exec(char *path, char **argv)
   uint64 oldsz = p->sz;
 
   p->max_mmaped = 0;
+  for(int i = 0; i < NMAPPINGS; i++) {
+    p->file_mappings[i].va = 0;
+    p->file_mappings[i].fd = -1;
+  }
 
   // Allocate two pages at the next page boundary.
   // Make the first inaccessible as a stack guard.
diff --git a/kernel/fs.c b/kernel/fs.c
index a88663e..49cb937 100644
--- a/kernel/fs.c
+++ b/kernel/fs.c
@@ -370,7 +370,7 @@ iunlockput(struct inode *ip)
 // Return the disk block address of the nth block in inode ip.
 // If there is no such block, bmap allocates one.
 // returns 0 if out of disk space.
-static uint
+uint
 bmap(struct inode *ip, uint bn)
 {
   uint addr, *a;
diff --git a/kernel/proc.h b/kernel/proc.h
index 7acb054..5e978b6 100644
--- a/kernel/proc.h
+++ b/kernel/proc.h
@@ -97,6 +97,14 @@ struct trapframe {
 
 enum procstate { UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
 
+
+struct mmap_file_mappings {
+    uint64 va;
+    int fd; //fd < 0 --> invalid mapping
+};
+
+#define NMAPPINGS 64
+
 // Per-process state
 struct proc {
   struct spinlock lock;
@@ -116,6 +124,7 @@ struct proc {
   uint64 sz;                   // Size of process memory (bytes)
   pagetable_t pagetable;       // User page table
   uint64 max_mmaped;           // max mmaped address
+  struct mmap_file_mappings file_mappings[NMAPPINGS]; // maps virtual addresses to file descriptors
   struct trapframe *trapframe; // data page for trampoline.S
   struct context context;      // swtch() here to run process
   struct file *ofile[NOFILE];  // Open files
diff --git a/kernel/sysproc.c b/kernel/sysproc.c
index b339822..5b0e8e0 100644
--- a/kernel/sysproc.c
+++ b/kernel/sysproc.c
@@ -96,11 +96,24 @@ sys_mmap(void) {
   argint(4, &fildes);
   argint(5, &off);
 
-  if(len == 0 || fildes != -1 || off != 0 
-  || (flags | MAP_FIXED | MAP_FIXED_NOREPLACE | MAP_POPULATE) != (MAP_ANONYMOUS | MAP_PRIVATE | MAP_FIXED | MAP_FIXED_NOREPLACE | MAP_POPULATE)) {
-    printf("[K] sys_mmap: unsupported parameter(s)\n");
+  if (len <= 0 || off != 0) {
+    printf("[K] sys_mmap: unsupported parameter(s): invalid length or offset\n");
     return -1;
   }
+  if ((flags) & ~(MAP_ANONYMOUS | MAP_PRIVATE | MAP_SHARED | MAP_FIXED | MAP_FIXED_NOREPLACE | MAP_POPULATE)) {
+    printf("[K] sys_mmap: unsupported parameter(s): unsupported flags\n");
+    return -1;
+  }
+  if ((flags & MAP_SHARED) ? fildes < 0 : 0) {
+    printf("[K] sys_mmap: unsupported parameter(s): MAP_SHARED + invalid file descriptor\n");
+    return -1;
+  }
+  if ((flags & MAP_SHARED) && (flags & MAP_PRIVATE)) {
+    printf("[K] sys_mmap: unsupported parameter(s): MAP_SHARED + MAP_PRIVATE\n");
+    return -1;
+  }
+
+
   if(addr % PGSIZE != 0) {
     printf("[K] sys_mmap: addr not page aligned\n");
     return -1;
@@ -109,6 +122,7 @@ sys_mmap(void) {
     printf("[K] sys_mmap: MAP_FIXED: invalid address\n");
     return -1;
   }
+
   // printf("[K] sys_mmap: mapping length %d with flags %x and prot %x\n", len, flags, prot);
 
   uint64 npages = PGROUNDUP(len) / PGSIZE;
@@ -116,11 +130,11 @@ sys_mmap(void) {
 
   uint64 start_va = addr > MMAP_BASE ? addr : MMAP_BASE;
 
-  uint64 ret_addr = uvmmap(p->pagetable, start_va, npages, prot, flags);
-
-  p->max_mmaped = (ret_addr + npages * PGSIZE > p->max_mmaped) ? 
-      ret_addr + npages * PGSIZE
-      : p->max_mmaped;
+  uint64 ret_addr = uvmmap(p->pagetable, start_va, npages, fildes, prot, flags);
+  if(ret_addr != -1ULL) {
+    p->max_mmaped = (ret_addr + npages * PGSIZE > p->max_mmaped) ?
+                    ret_addr + npages * PGSIZE : p->max_mmaped;
+  }
   // printf("[K] sys_mmap: ret_addr=%p npages=%d\n", ret_addr, npages);
   return ret_addr;
 }
diff --git a/kernel/vm.c b/kernel/vm.c
index cdf2897..c9770af 100644
--- a/kernel/vm.c
+++ b/kernel/vm.c
@@ -1,6 +1,7 @@
 #include "memlayout.h"
 #include "defs.h"
 #include "mmap.h"
+#include "buf.h"
 
 /*
  * the kernel's page table.
@@ -278,7 +279,7 @@ static uint64 find_va(pagetable_t pagetable, uint64 search_start, uint64 npages,
 }
 
 uint64
-uvmmap(pagetable_t pagetable, uint64 prefferered_addr, uint64 npages, int perm, int flags)
+uvmmap(pagetable_t pagetable, uint64 prefferered_addr, uint64 npages, int fildes, int perm, int flags)
 {
 
   uint64 map_at = find_va(pagetable, prefferered_addr, npages, flags & (MAP_FIXED | MAP_FIXED_NOREPLACE));
@@ -291,33 +292,84 @@ uvmmap(pagetable_t pagetable, uint64 prefferered_addr, uint64 npages, int perm,
       }
       map_at = prefferered_addr;
     } else
-    return -1;
+      return -1;
   }
   // printf("[K] uvmmap: mapping %d pages at %p\n", npages, map_at);
   int clean_perm = PTE_U 
             | ((perm & PROT_READ) ? PTE_R : 0) 
             | ((perm & PROT_WRITE) ? PTE_W : 0) 
             | ((perm & PROT_EXEC) ? PTE_X : 0);
-  
-  for(int i = 0; i < npages; i++)
-  {
-    char *mem = kalloc();
-    if(mem == 0)
-    {
-      uvmunmap(pagetable, map_at, i, 1);
+
+  if(fildes < 0){
+    for(int i = 0; i < npages; i++) {
+      char *mem = kalloc();
+      if(mem == 0) {
+        uvmunmap(pagetable, map_at, i, 1);
+        return -1;
+      }
+      uint64 *to_clear = (uint64*) mem;
+      for(int j = 0; j < PGSIZE/8; j++)
+        to_clear[j] = 0;
+      // printf("[K] mapping page %d at %p\n", i, map_at + i*PGSIZE);
+      if (mappages(pagetable, map_at + i*PGSIZE, PGSIZE, (uint64) mem, clean_perm) != 0)
+        {
+          printf("[K] uvmmap: mappages failed\n");
+          uvmunmap(pagetable, map_at, i, 1);
+          kfree(mem);
+          return -1;
+        }
+    }
+  } else {
+    // map a file
+    struct proc *p = myproc();
+    if(fildes > NOFILE || p->ofile[fildes] == 0) {
       return -1;
     }
-    uint64 *to_clear = (uint64*)mem;
-    for(int j = 0; j < PGSIZE/8; j++)
-      to_clear[j] = 0;
-    // printf("[K] mapping page %d at %p\n", i, map_at + i*PGSIZE);
-    if(mappages(pagetable, map_at + i*PGSIZE, PGSIZE, (uint64)mem, clean_perm) != 0)
-    {
-      printf("uvmmap: mappages failed\n");
-      uvmunmap(pagetable, map_at, i, 1);
-      kfree(mem);
+    struct file *to_map = p->ofile[fildes];
+    if(to_map->type != FD_INODE) {
       return -1;
     }
+
+    //find index in mapping
+    int i;
+    for(i = 0; i < NMAPPINGS; i++) {
+      if(p->file_mappings[i].fd < 0)
+        break;
+    }
+    if(i == NMAPPINGS) {
+      printf("[K] uvmmap: maximum number of file mappings exceeded \n");
+      return -1;
+    }
+    p->file_mappings[i].fd = fildes;
+    p->file_mappings[i].va = map_at;
+
+    //map buffer.data auf va for all pages
+
+    if(to_map->type != FD_INODE) {
+      printf("[K] Mapping non-inode files is not implemented yet.\n");
+      return -1;
+    }
+    // We are evil, so we are allowed to that. If you think otherwise, please cast us `Time Stop' for 10 hours.
+    struct buf *alloc_buffers[npages];
+//    begin_op();
+//    ilock(to_map->ip);
+    for(int page = 0; page < npages; page++) {
+      uint dev_addr = bmap(to_map->ip, page);
+      struct buf *bp = bread(to_map->ip->dev, dev_addr);
+      alloc_buffers[page] = bp;
+      if (mappages(pagetable, map_at + i*PGSIZE, PGSIZE, (uint64) bp->data, clean_perm) != 0)
+      {
+        printf("[K] uvmmap: mappages failed\n");
+        uvmunmap(pagetable, map_at, i, 1);
+        for(int j = 0; j <= page; j++)
+          brelse(alloc_buffers[j]);
+//        iunlock(to_map->ip);
+//        end_op();
+        return -1;
+      }
+    }
+//    iunlock(to_map->ip);
+//    end_op();
   }
   // printf("[K] uvmmap: mapped %d pages at %p\n", npages, map_at);
   return map_at;
diff --git a/rt-test/alloc-test-bpa.cc b/rt-test/alloc-test-bpa.cc
index 3231f43..36f9fa3 100644
--- a/rt-test/alloc-test-bpa.cc
+++ b/rt-test/alloc-test-bpa.cc
@@ -7,6 +7,8 @@
 #include "user/bmalloc.h"
 
 void main() {
+  term();
+  return;
   setup_balloc();
   for (int i = 4096; i < 1 << 16; ++i) {
     auto block = block_alloc(i, 4096);
diff --git a/rt-test/mmap-test-file.cc b/rt-test/mmap-test-file.cc
deleted file mode 100644
index fc8ef4d..0000000
--- a/rt-test/mmap-test-file.cc
+++ /dev/null
@@ -1,22 +0,0 @@
-/*!
- * \file
- * \brief test general mmap
- */
-
-
-#include <rt-test/assert.h>
-#include <user/mmap.h>
-
-void main() {
-  for (int i = 1; i < 64; ++i) {
-    auto size  = i * 4096;
-    void *data = mmap(0, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
-    assert(data != MAP_FAILED);
-    auto ptr = reinterpret_cast<volatile char *>(data);
-    for (int j = 0; j < size; ++j) {
-      ptr[j] = j;
-      assert(ptr[j] == char(j));
-    }
-    assert(!munmap(data, size));
-  }
-}
diff --git a/user/bmalloc.h b/user/bmalloc.h
index a46c667..2be4f1e 100644
--- a/user/bmalloc.h
+++ b/user/bmalloc.h
@@ -92,12 +92,8 @@ block block_alloc(uint32_t size, uint32_t align);
 void block_free(block block);
 void setup_balloc(void);
 
-
-
 void setup_malloc(void);
 
-
-
 #ifdef __cplusplus
 }
 
